<?php
/**
 * @file
 * Exposes functionality for manually cropping an image.
 */

require_once 'manualcrop.helpers.inc';
require_once 'manualcrop.admin.inc';

/**
 * Implements hook_help().
 */
function manualcrop_help($path) {
  switch ($path) {
    case 'admin/config/media/image-styles/edit/%':
      return '<p>' . t("<strong>Note:</strong> if you are using a Manual Crop effect, it's forced to be the only Manual Crop effect and first effect in the list.") . '</p>';
  }
}

/**
 * Implements hook_theme().
 */
function manualcrop_theme() {
  return array(
    'manualcrop_crop_and_scale_summary' => array(
      'variables' => array('data' => NULL),
    ),
    'manualcrop_crop_summary' => array(
      'variables' => array('data' => NULL),
    ),
    'manualcrop_overlay' => array(
      'variables' => array('fid' => NULL, 'path' => NULL),
    ),
    'manualcrop_widget' => array(
      'render element' => 'element',
    ),
  );
}

/**
 * Implements hook_field_widget_info().
 */
function manualcrop_field_widget_info() {
  return array(
    'manualcrop_image' => array(
      'label' => t('Manual image crop'),
      'field types' => array('image'),
      'settings' => array(
        'progress_indicator' => 'throbber',
        'preview_image_style' => 'thumbnail',
      ),
      'behaviors' => array(
        'multiple values' => FIELD_BEHAVIOR_CUSTOM,
        'default value' => FIELD_BEHAVIOR_NONE,
      ),
    ),
  );
}

/**
 * Implements hook_field_widget_form().
 */
function manualcrop_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
  // Use the image field widget form.
  $elements = image_field_widget_form($form, $form_state, $field, $instance, $langcode, $items, $delta, $element);

  // Get the widget settings.
  $instance = field_widget_instance($element, $form_state);

  // Generate and set the settings for each style effect.
  $settings = array();
  foreach (manualcrop_get_styles_with_crop() as $style_name => $data) {
    $settings[$style_name] = array(
      'effect' => $data['name'],
      'data' => $data['data']
    );
  }

  // Add the JavaScript settings (required styles).
  $form['#attached']['js'][] = array('data' => array('manualCrop' => array(
    'styles' => $settings,
    'required' => array(drupal_clean_css_identifier($instance['field_name']) => manualcrop_instance_required_styles($instance)),
  )), 'type' => 'setting');

  // Add a process function to the elements.
  foreach ($elements as $key => $child) {
    if (isset($child['#process']) && is_array($child['#process']) && in_array('image_field_widget_process', $child['#process'])) {
	  $elements[$key]['#process'][] = 'manualcrop_field_widget_process';
      $elements[$key]['#element_validate'][] = 'manualcrop_validate_crop_selection';
    }
  }

  if (!isset($form_state['manualcrop_widget_data'])) {
    $form_state['manualcrop_widget_data'] = array('images' => array());
  }
  else {
    // Reset the images array.
    $form_state['manualcrop_widget_data']['images'] = array();
  }

  return $elements;
}

/**
 * An element #process callback for the image_image field type.
 *
 * Expands the default image widget to allow cropping.
 */
function manualcrop_field_widget_process($element, &$form_state, $form) {
  $item = $element['#value'];
  $item['fid'] = $element['fid']['#value'];

  if ($element['#file'] && isset($_COOKIE['has_js']) && $_COOKIE['has_js']) {
    $hascrop = manualcrop_get_styles_with_crop();

    if (!empty($hascrop)) {
      // Get the widget settings.
      $instance = field_widget_instance($element, $form_state);
      $widget_settings = $instance['widget']['settings'];

      // Required image styles.
      $required = manualcrop_instance_required_styles($instance);

      // Exclude or include styles.
      if (isset($widget_settings['styles_mode']) && isset($widget_settings['styles_list'])) {
        $list = (isset($widget_settings['styles_list']) ? array_values($widget_settings['styles_list']) : array());

        // Filter hidden styles.
        if ($widget_settings['styles_mode'] == 'include') {
          $hascrop = array_intersect_key($hascrop, array_flip($list));
        }
        else {
          $hascrop = array_diff_key($hascrop, array_flip($list));
        }
      }

      if (!empty($hascrop)) {
        // Override the theming function.
        $element['#theme'] = 'manualcrop_widget';

        // Get image info, width and height are used by the cropping widget.
        $image = image_get_info($element['#file']->uri);

        // Save some images data to improve processing.
        $form_state['manualcrop_widget_data']['images'][$item['fid']] = array(
          'uri' => $element['#file']->uri,
          'filename' => $element['#file']->filename,
          'width' => $image['width'],
          'height' => $image['height'],
          'element_parents' => $element['#array_parents'],
          'required_styles' => $required,
        );

        // Get the saved selections for this file.
        if (!$form_state['submitted']) {
          $selections = manualcrop_load_crop_selection($element['#file']->uri);

          foreach ($selections as $data) {
            $item['manualcrop_selection'][$data->style_name] = $data->x . '|' . $data->y . '|' . $data->width . '|' . $data->height;
          }
        }

        // Overlay with the original image for cropping.
        $element['manualcrop_overlay'] = array(
          '#type' => 'markup',
          '#markup' => theme('manualcrop_overlay', array(
            'attributes' => array(
              'id' => array('manualcrop-overlay-' . $item['fid']),
              'class' => array('manualcrop-overlay', 'element-invisible'),
            ),
            'image' => array(
              'path' => $element['#file']->uri,
              'alt' => t('Manual Crop'),
              'width' => $image['width'],
              'height' => $image['height'],
              'attributes' => array('class' => 'manualcrop-image'),
            )
          )),
        );

        // Image style options.
        $options = array('' => t('Select a style to crop'));

        // Hidden fields to save the crop selection, one for each image style.
        foreach ($hascrop as $style_name => $data) {
          $element['manualcrop_selection'][$style_name] = array(
            '#type' => 'hidden',
            '#default_value' => (isset($item['manualcrop_selection'][$style_name]) ? $item['manualcrop_selection'][$style_name] : ''),
            '#attributes' => array(
              'id' => 'manualcrop-area-' . $item['fid'] . '-' . $style_name,
              'class' => array('manualcrop-cropdata'),
              'onchange' => 'ManualCrop.selectionStored(this, ' . $item['fid'] . ', \'' . $style_name . '\');',
            ),
          );

          $options[$style_name] = ucwords(str_replace('_', ' ', $style_name));
        }

        $props = array(
          '#weight' => (isset($element['title']['#weight']) ? $element['title']['#weight'] : 1),
            '#attached' => array(
              'css' => array(
                drupal_get_path('module', 'manualcrop') . '/manualcrop.css',
                drupal_get_path('module', 'manualcrop') . '/jquery.imgareaselect/css/imgareaselect-animated.css',
              ),
              'js' => array(
                drupal_get_path('module', 'manualcrop') . '/manualcrop.js',
                drupal_get_path('module', 'manualcrop') . '/jquery.imgareaselect/scripts/jquery.imgareaselect.pack.js',
              ),
            ),
        );

        if (sizeof($options) == 2) {
          $style_name_clean = end($options);
          $style_name = key($options);

          // Link for opening the overlay.
          $element['manualcrop_style'] = array_merge($props, array(
            '#type' => 'button',
            '#value' => t('Crop @stylename', array('@stylename' => $style_name_clean)),
            '#attributes' => array(
              'class' => array_merge(array('manualcrop-style-button', 'manualcrop-style-button-' . $item['fid']), (in_array($style_name, $required) ? array('manualcrop-style-required') : array())),
              'onclick' => "ManualCrop.showOverlay('" . $style_name . "', " . $item["fid"] . "); return false;",
            ),
            '#prefix' => '<div class="manualcrop-style-button-holder">',
            '#suffix' => '</div>',
          ));
        }
		else {
          // Selection list for opening the overlay.
          $element['manualcrop_style'] = array_merge($props, array(
            '#type' => 'select',
            '#title' => t('Manual Crop'),
            '#description' => t('Select the image style to crop, the corresponding cropping overlay will open.'),
            '#options' => $options,
            '#multiple' => FALSE,
            '#attributes' => array(
              'class' => array('manualcrop-style-select', 'manualcrop-style-select-' . $item['fid']),
              'onchange' => 'ManualCrop.showOverlay(this, ' . $item['fid'] . ');',
            ),
          ));
        }

        if ($element['alt']) {
          $element['alt']['#weight']--;
        }

        if ($element['title']) {
          $element['title']['#weight']--;
        }
      }
    }
  }

  return $element;
}

/**
 * Returns HTML for a Manual Crop image field widget.
 *
 * @param $variables
 *   An associative array containing:
 *   - "element": A render element representing the Manual Crop image field widget.
 *
 * @ingroup themeable
 */
function theme_manualcrop_widget($variables) {
  // Use the image widget theming function.
  return theme_image_widget($variables);
}

/**
 * Returns HTML for the crop area of an image.
 *
 * @param $variables
 *   An associative array containing:
 *   - "attributes": An array of attributes.
 *   - "image": An array of variables for the image theming function.
 *
 * @ingroup themeable
 */
function theme_manualcrop_overlay($variables) {
  $output = '<div ' . drupal_attributes($variables["attributes"]) . '>';

  $output .= '<div class="manualcrop-overlay-bg"></div>';

  $output .= '<div class="manualcrop-image-holder">';
  $output .= theme('image', $variables["image"]);
  $output .= '</div>';

  $output .= '<div class="manualcrop-details">';
  $output .= t('Image style') . ': <span class="manualcrop-details-value manualcrop-image-style">&nbsp;</span>, ';
  $output .= t('Selection x') . ': <span class="manualcrop-details-value manualcrop-selection-x">-</span>, ';
  $output .= t('Selection y') . ': <span class="manualcrop-details-value manualcrop-selection-y">-</span>, ';
  $output .= t('Selection width') . ': <span class="manualcrop-details-value manualcrop-selection-width">-</span>, ';
  $output .= t('Selection height') . ': <span class="manualcrop-details-value manualcrop-selection-height">-</span>';
  $output .= '</div>';

  $output .= '<div class="manualcrop-buttons">';
  $output .= '<a class="manualcrop-button manualcrop-reset" href="javascript:void(0);" onclick="ManualCrop.resetSelection(); this.blur();">' . t('Restore selection') . '</a>';
  $output .= '<a class="manualcrop-button manualcrop-clear" href="javascript:void(0);" onclick="ManualCrop.clearSelection(); this.blur();">' . t('Remove selection') . '</a>';
  $output .= '<a class="manualcrop-button manualcrop-close clearfix" href="javascript:void(0);" onclick="ManualCrop.closeOverlay(); this.blur();">' . t('Save selection') . '</a>';
  $output .= '</div>';

  $output .= '</div>';

  return $output;
}

/**
 * Form validation handler; Check the crop selections.
 *
 * @param $form
 *   Node form array.
 * @param $form_state
 *   Form state array.
 */
function manualcrop_validate_crop_selection($form, &$form_state) {
  if (!empty($form_state['manualcrop_widget_data']['images'])) {
    // Create a new key in the data array, this is to store processed selections.
    $form_state['manualcrop_widget_data']['selections'] = array();
    $save = &$form_state['manualcrop_widget_data']['selections'];

    // Loop trough the positions to get the manualcrop data.
    foreach ($form_state['manualcrop_widget_data']['images'] as $image) {
      $value = drupal_array_get_nested_value($form_state['values'], $image['element_parents']);

      if (isset($value['fid']) && isset($value['manualcrop_selection'])) {
        // Create a selections array for the current image, the first element is the path
        // to the original image, needed for flushing the cache.
        $save[$value['fid']] = array(
          'path' => $image['uri'],
          'styles' => array(),
        );

        $first = TRUE;

        foreach ($value['manualcrop_selection'] as $style_name => $selection) {
          if ($first) {
            $element_key = implode('][', $image['element_parents']) . '][manualcrop_style';
          }
          else {
            $element_key = implode('][', $image['element_parents']) . '][manualcrop_selection][' . $style_name;
          }

          if (!empty($selection)) {
            if (preg_match('/^([0-9]+\|){3}[0-9]+$/', $selection)) {
              $selection = array_map('intval', explode('|', $selection));

              // Check position and minimum dimensions.
              if ($selection[0] >= 0 && $selection[1] >= 0 && $selection[2] > 0 && $selection[3] > 0) {
                // Check if the selections fits on the image.
                if (($selection[0] + $selection[2]) <= $image['width'] && ($selection[1] + $selection[3]) <= $image['height']) {
                  $save[$value['fid']]['styles'][$style_name] = array(
                    'x' => $selection[0],
                    'y' => $selection[1],
                    'width' => $selection[2],
                    'height' => $selection[3],
                  );
                  continue;
                }
              }
            }

            form_set_error($element_key, t('The crop selection for %filename (@style image style) is invalid, please clear it or reselect.', array(
              '@style' => $style_name,
              '%filename' => $image['filename']
            )));

            $first = FALSE;
          }
          elseif (in_array($style_name, $image['required_styles'], TRUE)) {
            // Uncropped required style.
            form_set_error($element_key, t('%filename must have a cropping selection for the @style image style.', array(
              '@style' => $style_name,
              '%filename' => $image['filename']
            )));
          }
        }
      }
    }
  }
}

/**
 * Node form submit handler; Save the crop selection.
 *
 * @param $form
 *   Node form array.
 * @param $form_state
 *   Form state array.
 */
function manualcrop_field_attach_submit($entity_type, $entity, $form, &$form_state) {
  if (!empty($form_state['manualcrop_widget_data']['selections'])) {
    // Loop trough the selections to save them. $styles can by an empty array, but we loop trough
    // the whole array to delete old selections.
    foreach ($form_state['manualcrop_widget_data']['selections'] as $fid => $data) {
      db_delete('manualcrop')
        ->condition('fid', $fid)
        ->execute();

      foreach ($data['styles'] as $style_name => $selection) {
        db_insert('manualcrop')
          ->fields(array_merge($selection, array(
            'fid' => $fid,
            'style_name' => $style_name
          )))
          ->execute();
      }

      // Clear the cached versions of this image.
      image_path_flush($data['path']);

      if (variable_get('manualcrop_cache_control', TRUE)) {
        // Clear the cached image paths.
        cache_clear_all('manualcrop', 'cache', TRUE);
      }
    }
  }
}


/**
 * Implements hook_image_effect_info().
 */
function manualcrop_image_effect_info() {
  return array(
    'manualcrop_crop_and_scale' => array(
      'label' => t('Crop and scale manually'),
      'help' => t('Crop and scale a user-selected area, respecting the ratio of the destination width and height.'),
      'effect callback' => 'manualcrop_crop_and_scale_effect',
      'form callback' => 'manualcrop_crop_and_scale_form',
      'summary theme' => 'manualcrop_crop_and_scale_summary',
    ),
    'manualcrop_crop' => array(
      'label' => t('Manual Crop'),
      'help' => t('Crop a freely user-selected area.'),
      'effect callback' => 'manualcrop_crop_effect',
      'form callback' => 'manualcrop_crop_form',
      'summary theme' => 'manualcrop_crop_summary',
    ),
  );
}

/**
 * Image effect callback; Crop and scale an image resource.
 *
 * @param $image
 *   An image object returned by image_load().
 * @param $data
 *   An array of attributes to use when performing the Manual Crop and scale effect
 *   with the following items:
 *   - "width": An integer representing the desired width in pixels.
 *   - "height": An integer representing the desired height in pixels.
 *   - "upscale": A Boolean indicating that the image should be upscalled if
 *     the dimensions are larger than the original image.
 *   - "style_name": The style's machine name.
 * @return
 *   TRUE on success. FALSE on failure to crop and scale image.
 * @see image_crop_effect()
 * @see image_scale_effect()
 */
function manualcrop_crop_and_scale_effect(&$image, $data) {
  // The width and height will be possibly overwritten for the cropping, so copy the data array for later.
  $scale_data = $data;
  $crop = manualcrop_load_crop_selection($image->source, $data["style_name"]);

  if ($crop) {
    // Only crop if a crop was applied.
    $data["width"] = $crop->width;
    $data["height"] = $crop->height;
    $data["anchor"] = $crop->x . "-" . $crop->y;

    if (!image_crop_effect($image, $data)) {
      return FALSE;
    }
  }

  return image_scale_and_crop_effect($image, $scale_data);
}

/**
 * Image effect callback; Crop an image resource.
 *
 * @param $image
 *   An image object returned by image_load().
 * @param $data
 *   An array of attributes to use when performing the Manual Crop effect with the
 *   following items:
 *   - "width": An integer representing the desired width in pixels.
 *   - "height": An integer representing the desired height in pixels.
 *   - "upscale": A Boolean indicating that the image should be upscalled if
 *     the dimensions are larger than the original image.
 *   - "style_name": The style's machine name.
 * @return
 *   TRUE on success. FALSE on failure to crop image.
 * @see image_crop_effect()
 */
function manualcrop_crop_effect(&$image, $data) {
  $crop = manualcrop_load_crop_selection($image->source, $data["style_name"]);

  if ($crop) {
    $data["width"] = $crop->width;
    $data["height"] = $crop->height;
    $data["anchor"] = $crop->x . "-" . $crop->y;

    return image_crop_effect($image, $data);
  }

  return TRUE;
}

/**
 * Preprocessing for theme_image(); Force reloading of an image after re-cropping.
 *
 * @param $variables
 *   Image template variables.
 */
function manualcrop_preprocess_image(&$variables) {
  // Does the image style have a Manual Crop effect?
  $is_cropstyle = (isset($variables['style_name']) && array_key_exists($variables['style_name'], manualcrop_get_styles_with_crop()));

  // Is cache control enabled?
  $cache_control = variable_get('manualcrop_cache_control', TRUE);

  if ($is_cropstyle && $cache_control) {
    // Attempt to load HTTP cache-controller from database cache
    $original_path = $variables['path'];

    if ($cached_path = cache_get('manualcrop|' . $original_path)) {
      $variables['path'] = $cached_path->data;
    }
    else {
      // No HTTP cache-controller in database cache, get the image path.
      $match = '/styles/' . $variables['style_name'] . '/';
      $path = substr($variables['path'], (strrpos($variables['path'], $match) + drupal_strlen($match)));
      $path = explode('/', $path);

      // Build the image URI.
      $scheme = array_shift($path);
      $target = implode('/', $path);
      $image_uri = $scheme . '://' . urldecode($target);

      // Load the cropping area.
      if ($crop = manualcrop_load_crop_selection($image_uri, $variables['style_name'])) {
        // Add a HTTP cache-controller to the image path.
        $variables['path'] .= (strpos($variables['path'], '?q=') !== FALSE ? '&' : '?') . 'c=' . md5($crop->x . '|' . $crop->y . '|' . $crop->width . '|' . $crop->height);

        // Cache the the updated image path.
        cache_set('manualcrop|' . $original_path, $variables['path']);
      }
    }
  }
}

/**
 * Implements hook_image_style_delete().
 */
function manualcrop_image_style_delete($style) {
  if (!empty($style['effects'])) {
    $effect = reset($style['effects']);

    if ($effect['module'] == 'manualcrop') {
      db_delete('manualcrop')
        ->condition('style_name', $style['name'])
        ->execute();

      manualcrop_field_widget_update_names_in_settings($style['name']);
    }
  }
}

/**
 * Implements hook_file_delete().
 */
function manualcrop_file_delete($file) {
  db_delete('manualcrop')->condition('fid', $file->fid)->execute();
}

/**
 * Implements hook_filefield_sources_widgets().
 *
 * Integration with the Filefield Sources module.
 *
 * @see http://drupal.org/project/filefield_sources
 */
function manualcrop_filefield_sources_widgets() {
  return array('manualcrop_image');
}