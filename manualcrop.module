<?php
/**
 * @file
 * Exposes functionality for manually cropping an image.
 */

require_once 'manualcrop.helpers.inc';
require_once 'manualcrop.admin.inc';

/**
 * Implements hook_help().
 */
function manualcrop_help($path) {
  switch ($path) {
    case 'admin/config/media/image-styles/edit/%':
      return '<p>' . t("<strong>Note:</strong> if you are using a Manual Crop effect, it's forced to be the only Manual Crop effect and first effect in the list.") . '</p>';
  }
}

/**
 * Implements hook_theme().
 */
function manualcrop_theme() {
  return array(
    'manualcrop_crop_and_scale_summary' => array(
      'variables' => array('data' => NULL),
    ),
    'manualcrop_crop_summary' => array(
      'variables' => array('data' => NULL),
    ),
    'manualcrop_reuse_summary' => array(
      'variables' => array('data' => NULL),
    ),
    'manualcrop_croptool_overlay' => array(
      'variables' => array('attributes' => NULL, 'image' => NULL, 'crop_info' => TRUE, 'instant_preview' => FALSE),
    ),
    'manualcrop_croptool_inline' => array(
      'variables' => array('attributes' => NULL, 'image' => NULL, 'crop_info' => TRUE, 'instant_preview' => FALSE),
    ),
    'manualcrop_thumblist' => array(
      'variables' => array('attributes' => NULL, 'images' => NULL),
    ),
    'manualcrop_thumblist_image' => array(
      'variables' => array('attributes' => NULL, 'image' => NULL, 'style' => NULL),
    ),
  );
}

/**
 * Implements hook_image_style_delete().
 */
function manualcrop_image_style_delete($style) {
  if (!empty($style['effects'])) {
    $effect = reset($style['effects']);

    if ($effect['module'] == 'manualcrop') {
      db_delete('manualcrop')
        ->condition('style_name', $style['name'])
        ->execute();

      _manualcrop_field_widget_update_names_in_settings($style['name']);
      _manualcrop_reuse_effect_update_names_in_settings($style['name']);
    }
  }
}

/**
 * Implements hook_file_delete().
 */
function manualcrop_file_delete($file) {
  db_delete('manualcrop')->condition('fid', $file->fid)->execute();
}

/**
 * Implements hook_element_info().
 */
function manualcrop_element_info() {
  return array(
    'image_image' => array(
      '#after_build' => array('manualcrop_element_process'),
    ),
  );
}

/**
 * Implements hook_field_widget_info_alter().
 */
function manualcrop_field_widget_info_alter(&$info) {
  $defaults = array(
    // Enable Manual Crop?
    'manualcrop_enable' => FALSE,
    // Show a list of thubnails instead of a selection list or button?
    'manualcrop_thumblist' => FALSE,
    // Enable inline cropping?
    'manualcrop_inline_crop' => FALSE,
    // Show the crop info (width, height...)?
    'manualcrop_crop_info' => TRUE,
    // Automatically update the preview image?
    'manualcrop_instant_preview' => TRUE,
    // Open the crop tool after uploading?
    'manualcrop_instant_crop' => FALSE,
    // Show a default crop area when opening an uncropped image?
    'manualcrop_default_crop_area' => TRUE,
    // Exclude or include the selected styles?
    'manualcrop_styles_mode' => 'exclude',
    // List of selected styles.
    'manualcrop_styles_list' => array(),
    // List of required crop selections.
    'manualcrop_require_cropping' => array(),
  );

  if (module_exists('insert')) {
    // Filter all styles without a Manual Crop effect?
    $defaults['manualcrop_filter_insert'] = TRUE;
  }

  foreach (manualcrop_element_info() as $widget_type => $element) {
    if (isset($info[$widget_type]['settings'])) {
      $settings = &$info[$widget_type]['settings'];
      $settings += $defaults;

      if ($settings['manualcrop_styles_mode'] == 'include' && empty($settings['manualcrop_styles_list'])) {
        // No styles are included.
        $settings['enable'] = FALSE;
      }
      elseif ($settings['manualcrop_styles_mode'] == 'exlude' && !empty($settings['manualcrop_styles_list'])) {
        // Check if all styles are exluded.
        $styles = manualcrop_get_styles_with_crop();
        $styles = array_diff_key($styles, array_flip($settings['manualcrop_styles_list']));

        if (empty($styles)) {
          $settings['manualcrop_enable'] = FALSE;
        }
      }
    }
  }
}

/**
 * Process function for Manual Crop enabled widgets.
 */
function manualcrop_element_process($element) {
  if (module_exists('insert')) {
    manualcrop_insert_element_process($element);
  }

  return $element;
}

/**
 * Additional after build callback to modify form elements added by the Insert module.
 *
 * @param $element
 *   The element to process.
 */
function manualcrop_insert_element_process($element) {
  if (!empty($element['insert']['#options']) && !empty($element['manualcrop_selections'])) {
    $settings = $element['insert']['#widget']['settings'];

    if ($settings['manualcrop_filter_insert']) {
      // Make a list of all styles that should be visible in the widget.
      $styles = array('image' => 1);
      foreach (element_children($element['manualcrop_selections']) as $style) {
        $styles['image_' . $style] = 1;
      }

      // Filter hidden styles from Insert.
      $element['insert']['#options'] = array_intersect_key($element['insert']['#options'], $styles);

      // Make sure the default value is allowed.
      if (!array_key_exists($element['insert']['#default_value'], $element['insert']['#options'])) {
        reset($element['insert']['#options']);
        $element['insert']['#default_value'] = key($element['insert']['#options']);
      }
    }
  }

  return $element;
}

/**
 * Implements hook_insert_styles().
 */
function manualcrop_insert_styles() {
  $insert_styles = drupal_static(__FUNCTION__);

  if (is_null($insert_styles)) {
    $insert_styles = array();

    foreach (manualcrop_get_styles_with_crop() as $style_name => $effect) {
      $insert_styles['image_' . $style_name] = array(
        'label' => _manualcrop_image_style_name($style_name),
      );
    }
  }

  return $insert_styles;
}

/**
 * Preprocessing for theme_image(); Force reloading of an image after re-cropping.
 *
 * @param $variables
 *   Image template variables.
 */
function manualcrop_preprocess_image(&$variables) {
  // Does the image style have a Manual Crop effect?
  $is_cropstyle = (isset($variables['style_name']) && array_key_exists($variables['style_name'], manualcrop_get_styles_with_crop()));

  // Is cache control enabled?
  $cache_control = variable_get('manualcrop_cache_control', TRUE);

  if ($is_cropstyle && $cache_control) {
    // Attempt to load HTTP cache-controller from database cache.
    $original_path = $variables['path'];

    if ($cached_path = cache_get('manualcrop|' . $original_path)) {
      $variables['path'] = $cached_path->data;
    }
    else {
      // No HTTP cache-controller in database cache, get the image path.
      $match = '/styles/' . $variables['style_name'] . '/';
      $path = substr($variables['path'], (strrpos($variables['path'], $match) + drupal_strlen($match)));
      $path = explode('/', $path);

      // Build the image URI.
      $scheme = array_shift($path);
      $target = implode('/', $path);
      $image_uri = $scheme . '://' . urldecode($target);

      // Load the cropping area.
      if ($crop = manualcrop_load_crop_selection($image_uri, $variables['style_name'])) {
        // Add a HTTP cache-controller to the image path.
        $variables['path'] .= (strpos($variables['path'], '?q=') !== FALSE ? '&' : '?') . 'c=' . md5($crop->x . '|' . $crop->y . '|' . $crop->width . '|' . $crop->height);

        // Cache the the updated image path.
        cache_set('manualcrop|' . $original_path, $variables['path']);
      }
    }
  }
}

/**
 * Returns HTML for the overlay crop area of an image.
 *
 * @param $variables
 *   An associative array containing:
 *   - "attributes": An array of attributes.
 *   - "image": An array of variables for the image theming function.
 *
 * @ingroup themeable
 */
function theme_manualcrop_croptool_overlay($variables) {
  $output = '<div ' . drupal_attributes($variables['attributes']) . '>';

  $output .= '<div class="manualcrop-overlay-bg"></div>';

  $output .= '<div class="manualcrop-image-holder">';
  $output .= theme('image', $variables["image"]);
  $output .= '</div>';

  if ($variables['instant_preview']) {
    $output .= '<div class="manualcrop-instantpreview"></div>';
  }

  if ($variables['crop_info']) {
    $output .= '<div class="manualcrop-details">';
    $output .= t('Image style') . ': <span class="manualcrop-details-value manualcrop-image-style">&nbsp;</span>, ';
    $output .= t('Selection x') . ': <span class="manualcrop-details-value manualcrop-selection-x">-</span>, ';
    $output .= t('Selection y') . ': <span class="manualcrop-details-value manualcrop-selection-y">-</span>, ';
    $output .= t('Selection width') . ': <span class="manualcrop-details-value manualcrop-selection-width">-</span>, ';
    $output .= t('Selection height') . ': <span class="manualcrop-details-value manualcrop-selection-height">-</span>';
    $output .= '</div>';
  }

  $output .= '<div class="manualcrop-buttons">';
  $output .= '<a class="manualcrop-button manualcrop-reset" href="javascript:void(0);" onmousedown="ManualCrop.closeCroptool(true);">' . t('Cancel') . '</a>';
  $output .= '<a class="manualcrop-button manualcrop-clear" href="javascript:void(0);" onmousedown="ManualCrop.clearSelection();">' . t('Remove selection') . '</a>';
  $output .= '<a class="manualcrop-button manualcrop-reset" href="javascript:void(0);" onmousedown="ManualCrop.resetSelection();">' . t('Revert selection') . '</a>';
  $output .= '<a class="manualcrop-button manualcrop-close" href="javascript:void(0);" onmousedown="ManualCrop.closeCroptool();">' . t('Save') . '</a>';
  $output .= '</div>';

  $output .= '</div>';

  return $output;
}

/**
 * Returns HTML for the inline crop area of an image.
 *
 * @param $variables
 *   An associative array containing:
 *   - "attributes": An array of attributes.
 *   - "image": An array of variables for the image theming function.
 *
 * @ingroup themeable
 */
function theme_manualcrop_croptool_inline($variables) {
  $output = '<div ' . drupal_attributes($variables['attributes']) . '>';

  $output .= '<div class="manualcrop-image-holder">';
  $output .= theme('image', $variables['image']);
  $output .= '</div>';

  $output .= '<div class="clearfix">';

  if ($variables['instant_preview']) {
    $output .= '<div class="manualcrop-instantpreview"></div>';
  }

  if ($variables['crop_info']) {
    $output .= '<div class="manualcrop-details">';
    $output .= t('Image style') . ': <span class="manualcrop-details-value manualcrop-image-style">&nbsp;</span><br />';
    $output .= t('Selection x') . ': <span class="manualcrop-details-value manualcrop-selection-x">-</span><br />';
    $output .= t('Selection y') . ': <span class="manualcrop-details-value manualcrop-selection-y">-</span><br />';
    $output .= t('Selection width') . ': <span class="manualcrop-details-value manualcrop-selection-width">-</span><br />';
    $output .= t('Selection height') . ': <span class="manualcrop-details-value manualcrop-selection-height">-</span>';
    $output .= '</div>';
  }

  $output .= '<div class="manualcrop-buttons">';
  $output .= '<input type="button" value="' . t('Save') . '" class="manualcrop-button manualcrop-close form-submit" onmousedown="ManualCrop.closeCroptool();" />';
  $output .= '<input type="button" value="' . t('Revert selection') . '" class="manualcrop-button manualcrop-reset form-submit" onmousedown="ManualCrop.resetSelection();" />';
  $output .= '<input type="button" value="' . t('Remove selection') . '" class="manualcrop-button manualcrop-clear form-submit" onmousedown="ManualCrop.clearSelection();" />';
  $output .= '<input type="button" value="' . t('Cancel') . '" class="manualcrop-button manualcrop-cencel form-submit" onmousedown="ManualCrop.closeCroptool(true);" />';
  $output .= '</div>';

  $output .= '</div>';

  $output .= '</div>';

  return $output;
}

/**
 * Returns HTML for thumbnail list.
 *
 * @param $variables
 *   An associative array containing:
 *   - "attributes": An array of attributes.
 *   - "images": Array of images html, themed by the "manualcrop_thumblist_image" function an keyed by style name.
 *
 * @ingroup themeable
 */
function theme_manualcrop_thumblist($variables) {
  $output = '<div ' . drupal_attributes($variables['attributes']) . '>';
  $output .= '<div class="clearfix">';
  $output .= implode('', $variables['images']);
  $output .= '</div>';
  $output .= '</div>';

  return $output;
}

/**
 * Returns HTML for a single image in the thumbnail list.
 *
 * @param $variables
 *   An associative array containing:
 *   - "attributes": An array of attributes.
 *   - "image": Rendered image tag html.
 *   - "style": Clean style name.
 *
 * @ingroup themeable
 */
function theme_manualcrop_thumblist_image($variables) {
  $output = '<a ' . drupal_attributes($variables['attributes']) . '>';
  $output .= '<strong class="manualcrop-style-thumb-label">' . check_plain($variables['style']) . '</strong>';
  $output .= $variables['image'];
  $output .= '</a>';

  return $output;
}

/**
 * Implements hook_image_effect_info().
 */
function manualcrop_image_effect_info() {
  return array(
    'manualcrop_crop_and_scale' => array(
      'label' => t('Crop and scale manually'),
      'help' => t('Crop and scale a user-selected area, respecting the ratio of the destination width and height.'),
      'effect callback' => 'manualcrop_crop_and_scale_effect',
      'dimensions callback' => 'image_resize_dimensions',
      'form callback' => 'manualcrop_crop_and_scale_form',
      'summary theme' => 'manualcrop_crop_and_scale_summary',
    ),
    'manualcrop_crop' => array(
      'label' => t('Manual crop'),
      'help' => t('Crop a freely user-selected area.'),
      'effect callback' => 'manualcrop_crop_effect',
      'dimensions callback' => 'image_resize_dimensions',
      'form callback' => 'manualcrop_crop_form',
      'summary theme' => 'manualcrop_crop_summary',
    ),
    'manualcrop_reuse' => array(
      'label' => t('Reuse a Manual Crop selection'),
      'help' => 'Reuse a crop selection from another Manual Crop enabled image style.',
      'effect callback' => 'manualcrop_reuse_effect',
      'form callback' => 'manualcrop_reuse_form',
      'summary theme' => 'manualcrop_reuse_summary',
    ),
  );
}

/**
 * Image effect callback; Crop and scale an image resource.
 *
 * @param $image
 *   An image object returned by image_load().
 * @param $data
 *   An array of attributes, needed to perform the crop and scale effect, with
 *   the following items:
 *   - "width": An integer representing the desired width in pixels.
 *   - "height": An integer representing the desired height in pixels.
 *   - "upscale": A boolean indicating that the image should be upscalled if
 *     the dimensions are larger than the original image.
 *   - "onlyscaleifcrop": A boolean indicating that the image should only be scaled
 *     if it was cropped.
 *   - "style_name": The style's machine name.
 *
 * @return
 *   TRUE on success, FALSE on failure to crop and scale image.
 *
 * @see image_crop_effect()
 * @see image_scale_effect()
 */
function manualcrop_crop_and_scale_effect(&$image, $data) {
  // The width and height will be possibly overwritten for the cropping, so copy the data array for later.
  $scale_data = $data;
  $crop = manualcrop_load_crop_selection($image->source, $data["style_name"]);

  if ($crop) {
    // Only crop if a crop was applied.
    $data["width"] = $crop->width;
    $data["height"] = $crop->height;
    $data["anchor"] = $crop->x . "-" . $crop->y;

    if (!image_crop_effect($image, $data)) {
      return FALSE;
    }
  }
  elseif (!empty($data['onlyscaleifcrop'])) {
    return TRUE;
  }

  return image_scale_and_crop_effect($image, $scale_data);
}

/**
 * Image effect callback; Crop an image resource.
 *
 * @param $image
 *   An image object returned by image_load().
 * @param $data
 *   An array of attributes, needed to perform the crop effect, with the
 *   following items:
 *   - "width": An integer representing the desired width in pixels.
 *   - "height": An integer representing the desired height in pixels.
 *   - "style_name": The style's machine name.
 *
 * @return
 *   TRUE on success, FALSE on failure to crop image.
 *
 * @see image_crop_effect()
 */
function manualcrop_crop_effect(&$image, $data) {
  $crop = manualcrop_load_crop_selection($image->source, $data["style_name"]);

  if ($crop) {
    $data["width"] = $crop->width;
    $data["height"] = $crop->height;
    $data["anchor"] = $crop->x . "-" . $crop->y;

    return image_crop_effect($image, $data);
  }

  return TRUE;
}

/**
 * Image effect callback; Reuse a Manual Crop effect.
 *
 * @param $image
 *   An image object returned by image_load().
 * @param $data
 *   An array of settings, needed to perform the reuse effect, with the
 *   following items:
 *   - "reusestyle": The image style to reuse.
 *
 * @return
 *   TRUE on success, FALSE on failure to reuse the effect.
 *
 * @see image_crop_effect()
 */
function manualcrop_reuse_effect(&$image, $data) {
  if (empty($data['reusestyle'])) {
    return FALSE;
  }

  // Load the selected image style and gat the first effect.
  $style = image_style_load($data['reusestyle']);
  $effect = reset($style['effects']);

  if (_manualcrop_is_crop_effect($effect)) {
    // Apply the Manual Crop cropping effect.
    image_effect_apply($image, $effect);
    return TRUE;
  }

  return FALSE;
}
